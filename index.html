<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Collector</title>
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json"> 
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        /* Custom styles for the game container and canvas */
        body {
            background-color: #0d0c1d; /* Deep Space Blue */
            font-family: 'Orbitron', sans-serif;
            color: #c9fbff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            /* Optimized for desktop: wider container */
            width: 90vw;
            max-width: 800px; /* Allow wider game screen */
            aspect-ratio: 1 / 1.35; /* Slightly less tall aspect ratio */
            border: 4px solid #00f0ff;
            box-shadow: 0 0 20px #00f0ff;
            background-color: #000008;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        #gameCanvas {
            flex-grow = 1;
            display: block;
            touch-action: none; /* Prevent default touch behavior */
            /* Ensure canvas fills available space */
            width: 100%;
            height: 100%;
        }

        #uiPanel {
            background: rgba(0, 240, 255, 0.1);
            padding: 8px 16px;
            border-top: 2px solid #00f0ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            text-shadow: 0 0 5px #00f0ff;
            transition: background-color 0.1s;
            /* Fixed height for UI panel */
            min-height: 40px; 
        }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff4500;
            box-shadow: 0 0 30px #ff4500;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            max-width: 90%;
        }

        .action-button {
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: #0d0c1d;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(255, 69, 0, 0.5);
            transition: all 0.2s ease;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 69, 0, 0.7);
        }
        
        /* Style for the LLM buttons */
        #debriefButton, #listenButton {
            background: linear-gradient(135deg, #00f0ff, #008cff);
            color: #0d0c1d;
            box-shadow: 0 4px 10px rgba(0, 240, 255, 0.5);
        }
        #debriefButton:hover, #listenButton:hover {
            box-shadow: 0 6px 15px rgba(0, 240, 255, 0.7);
        }
        #listenButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }


        .glow {
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { text-shadow: 0 0 5px #c9fbff; }
            to { text-shadow: 0 0 10px #00f0ff, 0 0 15px #00f0ff; }
        }

        /* Leaderboard Specific Styles */
        #leaderboard {
            width: 100%;
            max-width: 300px;
            margin: 20px auto 0;
            text-align: left;
            font-size: 0.85rem;
            border-collapse: collapse;
        }
        #leaderboard th, #leaderboard td {
            padding: 4px 8px;
            border-bottom: 1px dashed rgba(0, 240, 255, 0.3);
        }
        #leaderboard th {
            color: #00f0ff;
            text-transform: uppercase;
        }
        
        /* Style for the LLM Debrief Container */
        #debriefContainer {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, query, limit, addDoc, getDocs, orderBy, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase functions/objects globally for use in the main script block
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            getFirestore,
            doc,
            collection,
            query,
            limit,
            addDoc,
            getDocs,
            orderBy,
            setLogLevel
        };
    </script>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="uiPanel">
        <span id="score" class="glow">SCORE: 0</span>
        <span id="lives" class="glow">LIVES: 3</span>
    </div>

    <div id="messageBox" class="hidden">
        <h2 id="messageTitle" class="text-2xl mb-4 text-orange-400"></h2>
        <p id="messageBody" class="mb-6"></p>

        <!-- LLM Debriefing Result Area -->
        <div id="debriefContainer" class="text-sm text-left mx-auto max-w-sm mb-4 p-3 rounded bg-blue-900/40 hidden">
            <h4 class="text-cyan-400 font-bold mb-2">STAR COMMAND DEBRIEF</h4>
            <p id="debriefText" class="text-gray-300"></p>
        </div>
        
        <!-- Leaderboard will be injected here -->
        <div id="leaderboard-container"></div>
        
        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
            <button id="startButton" class="action-button">START GAME</button>
            <button id="debriefButton" class="action-button hidden">Generate Debrief âœ¨</button>
            <!-- NEW: TTS Button -->
            <button id="listenButton" class="action-button hidden">Listen to Debrief ðŸ”Š</button>
        </div>
    </div>
</div>

<script type="text/javascript">
    // --- Global Variables and Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');
    const messageBox = document.getElementById('messageBox');
    const messageTitle = document.getElementById('messageTitle');
    const messageBody = document.getElementById('messageBody');
    const startButton = document.getElementById('startButton');
    const leaderboardContainer = document.getElementById('leaderboard-container');
    
    // New LLM Elements
    const debriefButton = document.getElementById('debriefButton');
    const debriefContainer = document.getElementById('debriefContainer');
    const debriefText = document.getElementById('debriefText');
    const listenButton = document.getElementById('listenButton'); // NEW
    const API_KEY = ""; // API key for Gemini LLM

    let gameLoopId;
    let gameState = 'loading'; // Start in loading state for Firebase
    let player, gameObjects, score, lives;
    let lastTime = 0;
    let timeToSpawn = 1.5;
    let timeSinceLastSpawn = 0;
    
    const PLAYER_COLOR = '#00f0ff';
    const ASTEROID_COLOR = '#ff4500';
    const STAR_COLOR = '#ffff00';
    const ENEMY_COLOR = '#ff00ff'; // Magenta for enemies/projectiles

    let currentDebriefText = ''; // Holds the generated debrief text for TTS

    // --- TTS Utility Functions (PCM to WAV conversion) ---

    // Converts base64 string to ArrayBuffer
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    // Converts PCM audio data to a WAV Blob
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        const dataSize = pcm16.byteLength;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        
        // Write WAV header
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // RIFF chunk
        writeString(view, 0, 'RIFF'); // ChunkID
        view.setUint32(4, 36 + dataSize, true); // ChunkSize
        writeString(view, 8, 'WAVE'); // Format

        // FMT sub-chunk
        writeString(view, 12, 'fmt '); // Subchunk1ID
        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
        view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
        view.setUint16(22, numChannels, true); // NumChannels
        view.setUint32(24, sampleRate, true); // SampleRate
        view.setUint32(28, byteRate, true); // ByteRate
        view.setUint16(32, blockAlign, true); // BlockAlign
        view.setUint16(34, bitsPerSample, true); // BitsPerSample

        // Data sub-chunk
        writeString(view, 36, 'data'); // Subchunk2ID
        view.setUint32(40, dataSize, true); // Subchunk2Size

        // Write PCM data
        let offset = 44;
        const pcmDataArray = new Int16Array(buffer, 44, pcm16.length);
        pcmDataArray.set(pcm16); // Copy the PCM data

        return new Blob([buffer], { type: 'audio/wav' });
    }

    // --- Firebase Variables ---
    let db;
    let auth;
    let appId;
    let userId;
    let isAuthReady = false;
    let isLeaderboardActive = true; 
    let highScores = [];

    // --- Firebase Initialization and Auth ---

    async function initFirebaseAndAuth() {
        if (!window.firebase) {
            console.error("Firebase SDKs not loaded.");
            isLeaderboardActive = false;
            initGame();
            return;
        }
        
        // 1. Get Config and App ID
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        if (!firebaseConfig) {
            // FIX: If config is missing (i.e., public GitHub Pages deployment), 
            // disable the leaderboard but proceed with the game.
            console.warn("Firebase config not available. Leaderboard disabled on public site.");
            isLeaderboardActive = false;
            isAuthReady = true; // Mark auth as ready for the core game logic
            userId = 'public_user'; // Mock user ID for local scorekeeping
            initGame();
            return;
        }

        try {
            // 2. Initialize App and Services (Only runs if config is present)
            const app = firebase.initializeApp(firebaseConfig);
            db = firebase.getFirestore(app);
            auth = firebase.getAuth(app);
            // firebase.setLogLevel('debug'); // Keep this line for debugging if needed

            // 3. Authenticate
            await new Promise(resolve => {
                const initialToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                
                const unsubscribe = firebase.onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated user found. ID:", userId);
                    } else if (initialToken) {
                        // Try custom token sign-in (for Canvas environment)
                        await firebase.signInWithCustomToken(auth, initialToken);
                        userId = auth.currentUser.uid;
                        console.log("Signed in with custom token. ID:", userId);
                    } else {
                        // Fallback: Sign in anonymously (for robust Canvas or private testing)
                        await firebase.signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                        console.log("Signed in anonymously. ID:", userId);
                    }
                    
                    isAuthReady = true;
                    isLeaderboardActive = true; // Ensure leaderboard is active if auth succeeded
                    unsubscribe();
                    resolve();
                });
            });

            // Proceed to game initialization after auth is complete
            initGame();
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // If initialization fails, disable leaderboards but still run the game
            isLeaderboardActive = false;
            isAuthReady = true;
            userId = 'error_user';
            // Do not show error screen, just proceed to game menu
            initGame(); 
        }
    }

    // --- Firestore Logic ---

    // Public collection path for high scores
    function getScoresCollectionRef() {
        if (!db || !isLeaderboardActive) return null;
        // Path: /artifacts/{appId}/public/data/highscores
        return firebase.collection(db, 'artifacts', appId, 'public', 'data', 'highscores');
    }

    async function saveHighScore() {
        if (!isAuthReady || score === 0 || !isLeaderboardActive) return;

        const scoresRef = getScoresCollectionRef();
        if (!scoresRef) return;

        try {
            await firebase.addDoc(scoresRef, {
                score: score,
                userId: userId,
                timestamp: Date.now()
            });
            console.log("High score saved:", score);
        } catch (e) {
            console.error("Error saving high score:", e);
        }
    }

    async function loadHighScores() {
        if (!isAuthReady || !isLeaderboardActive) return;

        const scoresRef = getScoresCollectionRef();
        if (!scoresRef) return;

        try {
            // Query for the top 10 scores, sorted descendingly
            const q = firebase.query(
                scoresRef,
                // We fetch enough data and sort client-side to avoid needing additional Firestore indexes.
                firebase.limit(100) 
            );

            const querySnapshot = await firebase.getDocs(q);
            let results = [];
            querySnapshot.forEach((doc) => {
                results.push({ id: doc.id, ...doc.data() });
            });

            // Client-side sorting
            results.sort((a, b) => b.score - a.score);
            highScores = results.slice(0, 10); // Take top 10
            
            console.log("High scores loaded:", highScores);
        } catch (e) {
            console.error("Error loading high scores:", e);
        }
    }
    
    function renderLeaderboard() {
        leaderboardContainer.innerHTML = ''; // Clear previous leaderboard

        if (!isLeaderboardActive) {
            leaderboardContainer.innerHTML = '<p class="mt-4 text-orange-400">Leaderboard is disabled on this public site.</p>';
            return;
        }

        if (highScores.length === 0) {
            leaderboardContainer.innerHTML = '<p class="mt-4 text-gray-500">No high scores yet.</p>';
            return;
        }

        let html = '<table id="leaderboard" class="mx-auto">';
        html += '<thead><tr><th>Rank</th><th>Score</th><th>User ID</th></tr></thead>';
        html += '<tbody>';

        highScores.forEach((entry, index) => {
            // Highlight the current user's entry
            const isCurrentUser = entry.userId === userId;
            const rowClass = isCurrentUser ? 'bg-orange-800/50' : '';

            // Truncate the User ID for display purposes
            const displayUserId = entry.userId.length > 8 ? 
                                  entry.userId.substring(0, 4) + '...' + entry.userId.substring(entry.userId.length - 4) : 
                                  entry.userId;

            html += `<tr class="${rowClass}">
                        <td class="text-center">${index + 1}</td>
                        <td class="text-right">${entry.score}</td>
                        <td>${displayUserId}</td>
                     </tr>`;
        });

        html += '</tbody></table>';
        leaderboardContainer.innerHTML = html;
    }

    // --- Gemini LLM Logic (New Feature) ---

    // Utility function for exponential backoff
    async function fetchWithRetry(url, options, maxRetries = 5) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(url, options);
                if (response.status !== 429) { // Not a Rate Limit error
                    return response;
                }
                const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                console.warn(`Rate limit hit, retrying in ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                console.error(`Fetch failed, retrying in ${delay / 1000}s...`, error);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw new Error("Failed to fetch after multiple retries.");
    }
    
    /**
     * Calls the Gemini API to generate a dramatic mission debrief based on the score.
     */
    async function generateCosmicDebrief() {
        debriefButton.disabled = true;
        debriefButton.textContent = "DEBRIEFING...";
        debriefContainer.classList.remove('hidden');
        debriefText.textContent = "Connecting to Star Command servers...";
        listenButton.classList.add('hidden'); // Hide listen button while generating text

        // Truncate user ID for lore purposes
        const userIdSnippet = userId.length > 8 ? 
                              userId.substring(0, 4) + '...' + userId.substring(userId.length - 4) : 
                              userId;

        const systemPrompt = 
            `You are the Star Command's Mission Debriefing AI, codename 'ORACLE-7'. 
            Your reports must be dramatic, concise (under 80 words), and written in a formal, sci-fi tone. 
            The goal is to summarize the pilot's performance based on their score.`;
        
        const userQuery = 
            `Pilot ${userIdSnippet} achieved a final score of ${score}. 
            Generate the official mission report, focusing on whether the pilot's score indicates
            a heroic sacrifice, a masterful collection, or a reckless failure.`;

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            config: { temperature: 0.8 } // Allow for more creative flair
        };

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;

            if (generatedText) {
                currentDebriefText = generatedText.trim(); // STORE TEXT
                debriefText.textContent = currentDebriefText;
                
                // SHOW LISTEN BUTTON
                listenButton.classList.remove('hidden');
                listenButton.textContent = "Listen to Debrief ðŸ”Š";
                listenButton.disabled = false;
            } else {
                currentDebriefText = '';
                debriefText.textContent = "ERROR: Transmission failed. Pilot's fate remains unknown.";
                listenButton.classList.add('hidden');
            }

        } catch (error) {
            console.error("Gemini API call failed:", error);
            debriefText.textContent = "ERROR: Cannot establish quantum link with ORACLE-7. Check console for details.";
        } finally {
            debriefButton.textContent = "Debrief Generated";
        }
    }
    
    /**
     * Calls the Gemini TTS API to generate and play audio for the debrief text.
     */
    async function readCosmicDebrief(textToSpeak) {
        if (!textToSpeak) return;

        listenButton.disabled = true;
        listenButton.textContent = "TRANSMITTING...";
        
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        const TTS_VOICE = "Charon"; // Informative, good for a command AI

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${API_KEY}`;
        
        const payload = {
            contents: [{ 
                parts: [{ 
                    text: `Read the following Star Command Debrief with an informative and formal tone: ${textToSpeak}`
                }] 
            }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: TTS_VOICE }
                    }
                }
            }
        };

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const match = mimeType.match(/rate=(\d+)/);
                const sampleRate = match ? parseInt(match[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                const audioUrl = URL.createObjectURL(wavBlob);
                
                // Play the audio
                const audio = new Audio(audioUrl);
                audio.play();
                
                listenButton.textContent = "Playing...";
                audio.onended = () => {
                    listenButton.textContent = "Listen Again ðŸ”Š";
                    listenButton.disabled = false;
                };
                
            } else {
                debriefText.textContent += "\n[TTS ERROR: Audio format incompatible or missing data.]";
                listenButton.textContent = "Failed to Listen ðŸ”Š";
                listenButton.disabled = false;
            }

        } catch (error) {
            console.error("Gemini TTS API call failed:", error);
            debriefText.textContent += "\n[TTS ERROR: Failed to generate audio.]";
        } finally {
            // Re-enable if error occurred before successful play start
            if (listenButton.textContent === "TRANSMITTING...") {
                listenButton.textContent = "Failed to Listen ðŸ”Š";
                listenButton.disabled = false;
            }
        }
    }


    // --- Game Objects and Drawing ---

    class Player {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.targetX = x; // Target position for smooth movement
            this.speed = 600; // Increased speed for desktop responsiveness
        }

        draw() {
            if (gameState !== 'running') return; // Only draw when running
            // Draw a simple spaceship/triangle
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x + this.radius, this.y + this.radius);
            ctx.lineTo(this.x - this.radius, this.y + this.radius);
            ctx.closePath();
            ctx.fill();

            // Draw a faint trail
            ctx.fillStyle = 'rgba(0, 240, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y + this.radius, this.radius / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        update(deltaTime) {
            // Move player smoothly towards the targetX using deltaTime
            const dx = this.targetX - this.x;
            const distance = Math.abs(dx);
            
            if (distance > 1) {
                const moveAmount = Math.min(distance, this.speed * deltaTime);
                this.x += dx > 0 ? moveAmount : -moveAmount;
            }

            // Clamp player position within the canvas boundaries
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        }

        // Used by input handlers to set the desired location
        setTargetX(newX) {
            this.targetX = newX;
        }
    }

    class GameObject {
        constructor(x, y, radius, color, velocityY) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocityY = velocityY;
            this.active = true;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        update(deltaTime) {
            this.y += this.velocityY * deltaTime;
            if (this.y > canvas.height + this.radius) {
                this.active = false; // Mark for removal
            }
        }
    }

    class Asteroid extends GameObject {
        constructor(x, y) {
            // Randomize size and speed
            const radius = Math.random() * 15 + 10;
            const velocityY = Math.random() * 100 + 150;
            super(x, y, radius, ASTEROID_COLOR, velocityY);
            this.rotation = 0;
            this.rotationSpeed = Math.random() * 2 - 1; // Faster rotation in radians/s
        }

        draw() {
            // Draw jagged asteroid shape instead of a perfect circle
            ctx.save();
            ctx.translate(this.x, this.y);
            // Use the rotation value calculated in the update method
            ctx.rotate(this.rotation); 

            ctx.fillStyle = this.color;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;

            ctx.beginPath();
            const segments = 8;
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const r = this.radius * (1 + (Math.random() * 0.3 - 0.15)); // Jitter radius
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        update(deltaTime) {
            super.update(deltaTime);
            // FIX: Correctly update rotation using deltaTime
            this.rotation += this.rotationSpeed * deltaTime;
        }
    }

    class Star extends GameObject {
        constructor(x, y) {
            const radius = 5;
            const velocityY = Math.random() * 80 + 100;
            super(x, y, radius, STAR_COLOR, velocityY);
        }
        
        draw() {
            // Draw a star shape (4-point cross) for better visibility
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;

            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius * 1.5);
            ctx.lineTo(this.x + this.radius * 0.5, this.y - this.radius * 0.5);
            ctx.lineTo(this.x + this.radius * 1.5, this.y);
            ctx.lineTo(this.x + this.radius * 0.5, this.y + this.radius * 0.5);
            ctx.lineTo(this.x, this.y + this.radius * 1.5);
            ctx.lineTo(this.x - this.radius * 0.5, this.y + this.radius * 0.5);
            ctx.lineTo(this.x - this.radius * 1.5, this.y);
            ctx.lineTo(this.x - this.radius * 0.5, this.y - this.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.shadowBlur = 0; // Reset shadow
        }
    }

    class EnemyShip extends GameObject {
        constructor(x, y) {
            const radius = 15;
            const velocityY = 100;
            super(x, y, radius, ENEMY_COLOR, velocityY);
            this.fireTimer = 0;
            this.fireRate = Math.random() * 3 + 2; // Fire every 2 to 5 seconds
        }

        draw() {
            // Draw a simple enemy ship (upside-down triangle)
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + this.radius);
            ctx.lineTo(this.x + this.radius, this.y - this.radius);
            ctx.lineTo(this.x - this.radius, this.y - this.radius);
            ctx.closePath();
            ctx.fill();
        }

        update(deltaTime) {
            super.update(deltaTime);
            this.fireTimer += deltaTime;
            if (this.fireTimer >= this.fireRate) {
                this.fireProjectile();
                this.fireTimer = 0;
            }
        }

        fireProjectile() {
            const projectile = new Projectile(this.x, this.y + this.radius, 5);
            gameObjects.push(projectile);
        }
    }

    class Projectile extends GameObject {
        constructor(x, y, radius) {
            // Projectiles are fast
            super(x, y, radius, ENEMY_COLOR, 300);
        }

        draw() {
            // Draw a small, bright magenta square/dot
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8;
            ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            ctx.shadowBlur = 0;
        }
    }

    // --- Game Logic Functions ---

    function initGame() {
        // CRITICAL FIX: Set canvas size based on its actual rendered size in the DOM
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        // Player initial position should be based on the newly set canvas dimensions
        // Place player near the bottom center (85% down from the top)
        player = new Player(canvas.width / 2, canvas.height * 0.85, 15, PLAYER_COLOR);
        
        // Reset game state
        gameObjects = [];
        score = 0;
        lives = 3;
        timeSinceLastSpawn = 0; // Reset timer
        currentDebriefText = ''; // Reset debrief text
        
        scoreDisplay.textContent = `SCORE: ${score}`;
        livesDisplay.textContent = `LIVES: ${lives}`;
        
        removeInputListeners(); // Clear old listeners before showing menu
        
        // Hide LLM results when showing menu
        debriefContainer.classList.add('hidden'); 
        debriefButton.classList.add('hidden');
        listenButton.classList.add('hidden'); // NEW: Hide TTS button
        debriefButton.disabled = false;
        debriefButton.textContent = "Generate Debrief âœ¨";
        
        showScreen('menu', 'ASTEROID ASSAULT', 'Move mouse to pilot the ship!');
        
        // Draw initial black screen/menu background
        ctx.fillStyle = '#000008';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function startGame() {
        if (gameState !== 'running') {
            gameState = 'running';
            messageBox.classList.add('hidden');
            lastTime = performance.now();
            
            // Re-add input listeners when the game starts
            addInputListeners(); 
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    function endGame() {
        gameState = 'gameover';
        cancelAnimationFrame(gameLoopId);
        removeInputListeners(); // Remove listeners on game over
        
        // Save the score before showing the screen
        if (isLeaderboardActive) {
            saveHighScore().then(() => {
                showScreen('gameover', 'GAME OVER', `Final Score: ${score}`);
            });
        } else {
            // If leaderboard is not active, show score immediately
            showScreen('gameover', 'GAME OVER', `Final Score: ${score}`);
        }
    }

    function showScreen(type, title, body) {
        messageTitle.textContent = title;
        messageBody.textContent = body;
        startButton.textContent = (type === 'menu' || type === 'error') ? 'START GAME' : 'PLAY AGAIN';
        messageBox.classList.remove('hidden');

        if (type === 'gameover') {
            debriefButton.classList.remove('hidden');
            listenButton.classList.add('hidden'); // Initially hide listen button
            loadHighScores().then(renderLeaderboard);
        } else {
            debriefButton.classList.add('hidden');
            listenButton.classList.add('hidden'); // Ensure hidden on menu/start
            debriefContainer.classList.add('hidden');
            renderLeaderboard(); // Renders placeholder if not active
        }
    }
    
    // --- Input Handlers ---
    
    // Unified function to handle input position from mouse or touch
    function handleInput(clientX) {
        if (gameState === 'running' && player) {
            const rect = canvas.getBoundingClientRect();
            // Calculate the position relative to the canvas
            const relativeX = clientX - rect.left; 
            player.setTargetX(relativeX);
        }
    }

    const mouseMoveHandler = (e) => {
        handleInput(e.clientX);
    };

    const mouseOutHandler = () => {
        // Optimization for desktop: If mouse leaves, stop horizontal movement
        if(gameState === 'running' && player) {
            player.setTargetX(player.x);
        }
    }

    const touchMoveHandler = (e) => {
        if (e.touches.length > 0) {
            e.preventDefault();
            handleInput(e.touches[0].clientX);
        }
    };
    
    // Function to add listeners
    function addInputListeners() {
        canvas.addEventListener('mousemove', mouseMoveHandler);
        canvas.addEventListener('mouseout', mouseOutHandler); 
        canvas.addEventListener('touchmove', touchMoveHandler, { passive: false });
    }

    // Function to remove listeners
    function removeInputListeners() {
        canvas.removeEventListener('mousemove', mouseMoveHandler);
        canvas.removeEventListener('mouseout', mouseOutHandler); 
        canvas.removeEventListener('touchmove', touchMoveHandler);
    }
    
    // Attach LLM button listeners
    debriefButton.addEventListener('click', generateCosmicDebrief);
    listenButton.addEventListener('click', () => {
        if (currentDebriefText) {
            readCosmicDebrief(currentDebriefText);
        }
    });

    // Handle start button click
    startButton.addEventListener('click', () => {
        if (gameState === 'loading' || gameState === 'error' || gameState === 'menu') {
            startGame();
        } else if (gameState === 'gameover') {
            // Re-initialize game to reset canvas size and player position before starting
            initGame(); 
            startGame();
        }
    });

    // --- Collision Detection ---

    function checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < obj1.radius + obj2.radius;
    }

    function handleCollisions() {
        for (let i = gameObjects.length - 1; i >= 0; i--) {
            const obj = gameObjects[i];

            if (checkCollision(player, obj)) {
                if (obj instanceof Star) {
                    score += 10;
                    scoreDisplay.textContent = `SCORE: ${score}`;
                    obj.active = false;
                } else if (obj instanceof Asteroid) {
                    // Asteroid hit
                    lives--;
                    livesDisplay.textContent = `LIVES: ${lives}`;
                    obj.active = false;
                    document.getElementById('uiPanel').style.backgroundColor = 'rgba(255, 69, 0, 0.4)';
                    setTimeout(() => document.getElementById('uiPanel').style.backgroundColor = 'rgba(0, 240, 255, 0.1)', 100);
                    
                } else if (obj instanceof EnemyShip || obj instanceof Projectile) {
                    // Instant game over on enemy/projectile hit
                    lives = 0;
                    obj.active = false;
                }
                
                if (lives <= 0) {
                    endGame();
                    return;
                }
            }
        }
        
        // Remove inactive objects
        gameObjects = gameObjects.filter(obj => obj.active);
    }
    
    // --- Spawning Logic ---

    function spawnObject(deltaTime) {
        timeSinceLastSpawn += deltaTime;

        // Decrease timeToSpawn as score increases for difficulty scaling
        if (score < 500) {
             timeToSpawn = Math.max(0.3, 1.5 - score / 1000); // Max spawn rate 0.3s
        } else {
             timeToSpawn = 0.3;
        }

        if (timeSinceLastSpawn >= timeToSpawn) {
            timeSinceLastSpawn = 0;

            const x = Math.random() * (canvas.width - 40) + 20;
            const y = -20;
            const type = Math.random();

            if (type < 0.6) {
                // 60% chance: Asteroid
                gameObjects.push(new Asteroid(x, y));
            } else if (type < 0.9) {
                // 30% chance: Star
                gameObjects.push(new Star(x, y));
            } else if (score > 100 && type < 1.0) {
                // 10% chance: Enemy Ship (only after 100 points)
                gameObjects.push(new EnemyShip(x, y));
            }
        }
    }
    
    // --- Game Loop ---

    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000; // Time in seconds
        lastTime = timestamp;

        if (gameState !== 'running') return;

        // Clear the canvas
        ctx.fillStyle = '#000008';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 1. Update
        player.update(deltaTime);
        gameObjects.forEach(obj => obj.update(deltaTime));
        
        spawnObject(deltaTime);
        handleCollisions();

        // 2. Draw
        gameObjects.forEach(obj => obj.draw());
        player.draw();

        gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // IMPORTANT FIX: When resizing, we must re-run initGame to correctly set canvas.width/height
    window.addEventListener('resize', initGame);
    
    // Start the Firebase initialization process
    window.onload = function () {
        initFirebaseAndAuth();
    }
    
    // --- PWA Service Worker Registration (Embedded) ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            // Note: Service Worker is registered using the manifest.json path, 
            // but the content should be provided in a separate service-worker.js file.
            // For a single HTML file deployment, we rely on the manifest link.
            navigator.serviceWorker.register('manifest.json', { scope: './' })
                .then(registration => {
                    console.log('ServiceWorker registered successfully: ', registration.scope);
                })
                .catch(err => {
                    console.warn('ServiceWorker registration failed: ', err);
                });
        });
    }

</script>
</body>
</html>
