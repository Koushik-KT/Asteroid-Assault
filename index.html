<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Collector</title>
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json"> 
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        /* Custom styles for the game container and canvas */
        body {
            background-color: #0d0c1d; /* Deep Space Blue */
            font-family: 'Orbitron', sans-serif;
            color: #c9fbff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 95vw;
            max-width: 600px;
            aspect-ratio: 1 / 1.5; /* Tall aspect ratio for mobile-friendly play area */
            border: 4px solid #00f0ff;
            box-shadow: 0 0 20px #00f0ff;
            background-color: #000008;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #gameCanvas {
            flex-grow: 1;
            display: block;
            touch-action: none; /* Prevent default touch behavior */
        }

        #uiPanel {
            background: rgba(0, 240, 255, 0.1);
            padding: 8px 16px;
            border-top: 2px solid #00f0ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            text-shadow: 0 0 5px #00f0ff;
            transition: background-color 0.1s; /* Add smooth transition for damage flash */
        }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff4500;
            box-shadow: 0 0 30px #ff4500;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            max-width: 90%; /* Ensure it fits on smaller screens */
        }

        .action-button {
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: #0d0c1d;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(255, 69, 0, 0.5);
            transition: all 0.2s ease;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 69, 0, 0.7);
        }

        .glow {
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { text-shadow: 0 0 5px #c9fbff; }
            to { text-shadow: 0 0 10px #00f0ff, 0 0 15px #00f0ff; }
        }

        /* Leaderboard Specific Styles */
        #leaderboard {
            width: 100%;
            max-width: 300px;
            margin: 20px auto 0;
            text-align: left;
            font-size: 0.85rem;
            border-collapse: collapse;
        }
        #leaderboard th, #leaderboard td {
            padding: 4px 8px;
            border-bottom: 1px dashed rgba(0, 240, 255, 0.3);
        }
        #leaderboard th {
            color: #00f0ff;
            text-transform: uppercase;
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, query, limit, addDoc, getDocs, orderBy, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase functions/objects globally for use in the main script block
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            getFirestore,
            doc,
            collection,
            query,
            limit,
            addDoc,
            getDocs,
            orderBy,
            setLogLevel
        };
    </script>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="uiPanel">
        <span id="score" class="glow">SCORE: 0</span>
        <span id="lives" class="glow">LIVES: 3</span>
    </div>

    <div id="messageBox" class="hidden">
        <h2 id="messageTitle" class="text-2xl mb-4 text-orange-400"></h2>
        <p id="messageBody" class="mb-6"></p>
        <!-- Leaderboard will be injected here -->
        <div id="leaderboard-container"></div>
        <button id="startButton" class="action-button">START GAME</button>
    </div>
</div>

<script type="text/javascript">
    // --- Global Variables and Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');
    const messageBox = document.getElementById('messageBox');
    const messageTitle = document.getElementById('messageTitle');
    const messageBody = document.getElementById('messageBody');
    const startButton = document.getElementById('startButton');
    const leaderboardContainer = document.getElementById('leaderboard-container');

    let gameLoopId;
    let gameState = 'loading'; // Start in loading state for Firebase
    let player, gameObjects, score, lives;
    let lastTime = 0;
    let timeToSpawn = 1.5;
    let timeSinceLastSpawn = 0;
    
    const PLAYER_COLOR = '#00f0ff';
    const ASTEROID_COLOR = '#ff4500';
    const STAR_COLOR = '#ffff00';
    const ENEMY_COLOR = '#ff00ff'; // Magenta for enemies/projectiles

    // --- Firebase Variables ---
    let db;
    let auth;
    let appId;
    let userId;
    let isAuthReady = false;
    let isLeaderboardActive = true; // NEW: Assume active unless config is missing or authentication fails
    let highScores = [];

    // --- Firebase Initialization and Auth ---

    async function initFirebaseAndAuth() {
        if (!window.firebase) {
            console.error("Firebase SDKs not loaded.");
            isLeaderboardActive = false;
            initGame();
            return;
        }
        
        // 1. Get Config and App ID
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        if (!firebaseConfig) {
            // FIX: If config is missing (i.e., public GitHub Pages deployment), 
            // disable the leaderboard but proceed with the game.
            console.warn("Firebase config not available. Leaderboard disabled on public site.");
            isLeaderboardActive = false;
            isAuthReady = true; // Mark auth as ready for the core game logic
            userId = 'public_user'; // Mock user ID for local scorekeeping
            initGame();
            return;
        }

        try {
            // 2. Initialize App and Services (Only runs if config is present)
            const app = firebase.initializeApp(firebaseConfig);
            db = firebase.getFirestore(app);
            auth = firebase.getAuth(app);
            // firebase.setLogLevel('debug'); // Keep this line for debugging if needed

            // 3. Authenticate
            await new Promise(resolve => {
                const initialToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                
                const unsubscribe = firebase.onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated user found. ID:", userId);
                    } else if (initialToken) {
                        // Try custom token sign-in (for Canvas environment)
                        await firebase.signInWithCustomToken(auth, initialToken);
                        userId = auth.currentUser.uid;
                        console.log("Signed in with custom token. ID:", userId);
                    } else {
                        // Fallback: Sign in anonymously (for robust Canvas or private testing)
                        await firebase.signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                        console.log("Signed in anonymously. ID:", userId);
                    }
                    
                    isAuthReady = true;
                    isLeaderboardActive = true; // Ensure leaderboard is active if auth succeeded
                    unsubscribe();
                    resolve();
                });
            });

            // Proceed to game initialization after auth is complete
            initGame();
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // If initialization fails, disable leaderboards but still run the game
            isLeaderboardActive = false;
            isAuthReady = true;
            userId = 'error_user';
            showScreen('error', 'Database Offline', 'Leaderboard connection failed. Game is playable.');
            initGame();
        }
    }

    // --- Firestore Logic ---

    // Public collection path for high scores
    function getScoresCollectionRef() {
        if (!db || !isLeaderboardActive) return null;
        // Path: /artifacts/{appId}/public/data/highscores
        return firebase.collection(db, 'artifacts', appId, 'public', 'data', 'highscores');
    }

    async function saveHighScore() {
        if (!isAuthReady || score === 0 || !isLeaderboardActive) return;

        const scoresRef = getScoresCollectionRef();
        if (!scoresRef) return;

        try {
            await firebase.addDoc(scoresRef, {
                score: score,
                userId: userId,
                timestamp: Date.now()
            });
            console.log("High score saved:", score);
        } catch (e) {
            console.error("Error saving high score:", e);
        }
    }

    async function loadHighScores() {
        if (!isAuthReady || !isLeaderboardActive) return;

        const scoresRef = getScoresCollectionRef();
        if (!scoresRef) return;

        try {
            // Query for the top 10 scores, sorted descendingly
            const q = firebase.query(
                scoresRef,
                // We fetch enough data and sort client-side to avoid needing additional Firestore indexes.
                firebase.limit(100) 
            );

            const querySnapshot = await firebase.getDocs(q);
            let results = [];
            querySnapshot.forEach((doc) => {
                results.push({ id: doc.id, ...doc.data() });
            });

            // Client-side sorting
            results.sort((a, b) => b.score - a.score);
            highScores = results.slice(0, 10); // Take top 10
            
            console.log("High scores loaded:", highScores);
        } catch (e) {
            console.error("Error loading high scores:", e);
        }
    }
    
    function renderLeaderboard() {
        leaderboardContainer.innerHTML = ''; // Clear previous leaderboard

        if (!isLeaderboardActive) {
            leaderboardContainer.innerHTML = '<p class="mt-4 text-orange-400">Leaderboard is disabled on this public site.</p>';
            return;
        }

        if (highScores.length === 0) {
            leaderboardContainer.innerHTML = '<p class="mt-4 text-gray-500">No high scores yet.</p>';
            return;
        }

        let html = '<table id="leaderboard" class="mx-auto">';
        html += '<thead><tr><th>Rank</th><th>Score</th><th>User ID</th></tr></thead>';
        html += '<tbody>';

        highScores.forEach((entry, index) => {
            // Highlight the current user's entry
            const isCurrentUser = entry.userId === userId;
            const rowClass = isCurrentUser ? 'bg-orange-800/50' : '';

            // Truncate the User ID for display purposes
            const displayUserId = entry.userId.length > 8 ? 
                                  entry.userId.substring(0, 4) + '...' + entry.userId.substring(entry.userId.length - 4) : 
                                  entry.userId;

            html += `<tr class="${rowClass}">
                        <td class="text-center">${index + 1}</td>
                        <td class="text-right">${entry.score}</td>
                        <td>${displayUserId}</td>
                     </tr>`;
        });

        html += '</tbody></table>';
        leaderboardContainer.innerHTML = html;
    }

    // --- Game Objects and Drawing ---

    class Player {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.targetX = x; // Target position for smooth movement
            this.speed = 450; // pixels per second
        }

        draw() {
            // Draw a simple spaceship/triangle
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x + this.radius, this.y + this.radius);
            ctx.lineTo(this.x - this.radius, this.y + this.radius);
            ctx.closePath();
            ctx.fill();

            // Draw a faint trail
            ctx.fillStyle = 'rgba(0, 240, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y + this.radius, this.radius / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        update(deltaTime) {
            // Move player smoothly towards the targetX using deltaTime
            const dx = this.targetX - this.x;
            const distance = Math.abs(dx);
            
            if (distance > 1) {
                const moveAmount = Math.min(distance, this.speed * deltaTime);
                this.x += dx > 0 ? moveAmount : -moveAmount;
            }

            // Clamp player position within the canvas boundaries
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        }

        // Used by input handlers to set the desired location
        setTargetX(newX) {
            this.targetX = newX;
        }
    }

    class GameObject {
        constructor(x, y, radius, color, velocityY) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocityY = velocityY;
            this.active = true;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        update(deltaTime) {
            this.y += this.velocityY * deltaTime;
            if (this.y > canvas.height + this.radius) {
                this.active = false; // Mark for removal
            }
        }
    }

    class Asteroid extends GameObject {
        constructor(x, y) {
            // Randomize size and speed
            const radius = Math.random() * 15 + 10;
            const velocityY = Math.random() * 100 + 150;
            super(x, y, radius, ASTEROID_COLOR, velocityY);
            this.rotation = 0;
            this.rotationSpeed = Math.random() * 0.5 - 0.25; // Random rotation direction
        }

        draw() {
            // Draw jagged asteroid shape instead of a perfect circle
            ctx.save();
            ctx.translate(this.x, this.y);
            this.rotation += this.rotationSpeed * (lastTime - performance.now()) / 1000;
            ctx.rotate(this.rotation);

            ctx.fillStyle = this.color;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;

            ctx.beginPath();
            const segments = 8;
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const r = this.radius * (1 + (Math.random() * 0.3 - 0.15)); // Jitter radius
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
    }

    class Star extends GameObject {
        constructor(x, y) {
            const radius = 5;
            const velocityY = Math.random() * 80 + 100;
            super(x, y, radius, STAR_COLOR, velocityY);
        }
        
        draw() {
            // Draw a star shape (4-point cross) for better visibility
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;

            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius * 1.5);
            ctx.lineTo(this.x + this.radius * 0.5, this.y - this.radius * 0.5);
            ctx.lineTo(this.x + this.radius * 1.5, this.y);
            ctx.lineTo(this.x + this.radius * 0.5, this.y + this.radius * 0.5);
            ctx.lineTo(this.x, this.y + this.radius * 1.5);
            ctx.lineTo(this.x - this.radius * 0.5, this.y + this.radius * 0.5);
            ctx.lineTo(this.x - this.radius * 1.5, this.y);
            ctx.lineTo(this.x - this.radius * 0.5, this.y - this.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.shadowBlur = 0; // Reset shadow
        }
    }

    class EnemyShip extends GameObject {
        constructor(x, y) {
            const radius = 15;
            const velocityY = 100;
            super(x, y, radius, ENEMY_COLOR, velocityY);
            this.fireTimer = 0;
            this.fireRate = Math.random() * 3 + 2; // Fire every 2 to 5 seconds
        }

        draw() {
            // Draw a simple enemy ship (upside-down triangle)
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + this.radius);
            ctx.lineTo(this.x + this.radius, this.y - this.radius);
            ctx.lineTo(this.x - this.radius, this.y - this.radius);
            ctx.closePath();
            ctx.fill();
        }

        update(deltaTime) {
            super.update(deltaTime);
            this.fireTimer += deltaTime;
            if (this.fireTimer >= this.fireRate) {
                this.fireProjectile();
                this.fireTimer = 0;
            }
        }

        fireProjectile() {
            const projectile = new Projectile(this.x, this.y + this.radius, 5);
            gameObjects.push(projectile);
        }
    }

    class Projectile extends GameObject {
        constructor(x, y, radius) {
            // Projectiles are fast
            super(x, y, radius, ENEMY_COLOR, 300);
        }

        draw() {
            // Draw a small, bright magenta square/dot
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8;
            ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            ctx.shadowBlur = 0;
        }
    }

    // --- Game Logic Functions ---

    function initGame() {
        // Set canvas size based on container
        const container = document.getElementById('gameContainer');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight - 40; // Subtract UI panel height

        player = new Player(canvas.width / 2, canvas.height - 50, 15, PLAYER_COLOR);
        gameObjects = [];
        score = 0;
        lives = 3;
        
        scoreDisplay.textContent = `SCORE: ${score}`;
        livesDisplay.textContent = `LIVES: ${lives}`;
        
        showScreen('menu', 'ASTEROID ASSAULT', 'Collect stars, dodge danger!');
    }

    function startGame() {
        if (gameState !== 'running') {
            gameState = 'running';
            messageBox.classList.add('hidden');
            lastTime = performance.now();
            timeSinceLastSpawn = 0;
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    function endGame() {
        gameState = 'gameover';
        cancelAnimationFrame(gameLoopId);
        
        // Save the score before showing the screen
        if (isLeaderboardActive) {
            saveHighScore().then(() => {
                showScreen('gameover', 'GAME OVER', `Final Score: ${score}`);
            });
        } else {
            // If leaderboard is not active, show score immediately
            showScreen('gameover', 'GAME OVER', `Final Score: ${score}`);
        }
    }

    function showScreen(type, title, body) {
        messageTitle.textContent = title;
        messageBody.textContent = body;
        startButton.textContent = (type === 'menu' || type === 'error') ? 'START GAME' : 'PLAY AGAIN';
        messageBox.classList.remove('hidden');

        if (type === 'gameover' && isLeaderboardActive) {
            loadHighScores().then(renderLeaderboard);
        } else {
            renderLeaderboard(); // Renders placeholder if not active
        }
    }
    
    // --- Input Handlers ---
    
    // Handle mouse movement
    canvas.addEventListener('mousemove', (e) => {
        if (gameState === 'running') {
            player.setTargetX(e.offsetX);
        }
    });

    // Handle touch movement
    canvas.addEventListener('touchmove', (e) => {
        if (gameState === 'running' && e.touches.length > 0) {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const rect = canvas.getBoundingClientRect();
            const relativeX = touchX - rect.left;
            player.setTargetX(relativeX);
        }
    });
    
    // Handle start button click
    startButton.addEventListener('click', () => {
        if (gameState === 'loading' || gameState === 'error' || gameState === 'menu') {
            startGame();
        } else if (gameState === 'gameover') {
            initGame();
            startGame();
        }
    });

    // --- Collision Detection ---

    function checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < obj1.radius + obj2.radius;
    }

    function handleCollisions() {
        for (let i = gameObjects.length - 1; i >= 0; i--) {
            const obj = gameObjects[i];

            if (checkCollision(player, obj)) {
                if (obj instanceof Star) {
                    score += 10;
                    scoreDisplay.textContent = `SCORE: ${score}`;
                    obj.active = false;
                } else if (obj instanceof Asteroid) {
                    // Asteroid hit
                    lives--;
                    livesDisplay.textContent = `LIVES: ${lives}`;
                    obj.active = false;
                    document.getElementById('uiPanel').style.backgroundColor = 'rgba(255, 69, 0, 0.4)';
                    setTimeout(() => document.getElementById('uiPanel').style.backgroundColor = 'rgba(0, 240, 255, 0.1)', 100);
                    
                } else if (obj instanceof EnemyShip || obj instanceof Projectile) {
                    // Instant game over on enemy/projectile hit
                    lives = 0;
                    obj.active = false;
                }
                
                if (lives <= 0) {
                    endGame();
                    return;
                }
            }
        }
        
        // Remove inactive objects
        gameObjects = gameObjects.filter(obj => obj.active);
    }
    
    // --- Spawning Logic ---

    function spawnObject(deltaTime) {
        timeSinceLastSpawn += deltaTime;

        // Decrease timeToSpawn as score increases for difficulty scaling
        if (score < 500) {
             timeToSpawn = Math.max(0.3, 1.5 - score / 1000); // Max spawn rate 0.3s
        } else {
             timeToSpawn = 0.3;
        }

        if (timeSinceLastSpawn >= timeToSpawn) {
            timeSinceLastSpawn = 0;

            const x = Math.random() * (canvas.width - 40) + 20;
            const y = -20;
            const type = Math.random();

            if (type < 0.6) {
                // 60% chance: Asteroid
                gameObjects.push(new Asteroid(x, y));
            } else if (type < 0.9) {
                // 30% chance: Star
                gameObjects.push(new Star(x, y));
            } else if (score > 100 && type < 1.0) {
                // 10% chance: Enemy Ship (only after 100 points)
                gameObjects.push(new EnemyShip(x, y));
            }
        }
    }
    
    // --- Game Loop ---

    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000; // Time in seconds
        lastTime = timestamp;

        if (gameState !== 'running') return;

        // Clear the canvas
        ctx.fillStyle = '#000008';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 1. Update
        player.update(deltaTime);
        gameObjects.forEach(obj => obj.update(deltaTime));
        
        spawnObject(deltaTime);
        handleCollisions();

        // 2. Draw
        gameObjects.forEach(obj => obj.draw());
        player.draw();

        gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Resize handler to maintain aspect ratio and reposition player
    window.addEventListener('resize', initGame);
    
    // Start the Firebase initialization process
    window.onload = function () {
        initFirebaseAndAuth();
    }
    
    // --- PWA Service Worker Registration (Embedded) ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('manifest.json', { scope: './' })
                .then(registration => {
                    console.log('ServiceWorker registered successfully: ', registration.scope);
                })
                .catch(err => {
                    console.warn('ServiceWorker registration failed: ', err);
                });
        });
    }

</script>
</body>
</html>
